#!/bin/bash
VM_LIST() {
(
for GROUP in $(ls /var/cld/access/groups/)
do
grep -qs "1" /var/cld/access/groups/${GROUP}/type \
&& cat /var/cld/access/groups/${GROUP}/clouds \
|| cut -d _ -f -4 /var/cld/access/groups/${GROUP}/clouds
done
) | grep -v "^$"
}

CLD_LOGS() {
mkdir -p /var/cld/log/session/ &>/dev/null
CLD_LOG=/var/cld/log/session/${SUDO_USER}_${VM}_`date +"%d-%m-%y_%H-%M"`
}

CLD_DEPLOY_LOGS() {
mkdir -p /var/cld/deploy/actions/${ACTION_NAME}/deploy_log &>/dev/null
CLD_ACTION_LOG=/var/cld/deploy/actions/${ACTION_NAME}/deploy_log/${VM}
[ "$TEST" == "1" ] && mkdir -p /var/cld/deploy/actions/${ACTION_NAME}/test_log &>/dev/null
[ "$TEST" == "1" ] && CLD_ACTION_TEST_LOG=/var/cld/deploy/actions/${ACTION_NAME}/test_log/${VM}
[ "$BACKUP" == "1" ] && mkdir -p /var/cld/deploy/actions/${ACTION_NAME}/backup_log &>/dev/null
[ "$BACKUP" == "1" ] && CLD_ACTION_BACKUP_LOG=/var/cld/deploy/actions/${ACTION_NAME}/backup_log/${VM}
}

EXTERNAL_VARS() {
VMN=`echo $VM | cut -d "_" -f 1`
SRV=`echo $VM | cut -d "_" -f 2`
PRT=`echo $VM | cut -d "_" -f 3`
USR=`echo $VM | cut -d "_" -f 4`
PWD=`grep $VM /var/cld/access/groups/${GROUP}/clouds | cut -d _ -f 5-`
}

EXTERNAL_MOUNT() {
LOCALMOUNTPATH="/home/${SUDO_USER}/mnt/${VM}"
if [ ! -d "$DIR" ]; then mkdir -p $LOCALMOUNTPATH ;fi
fusermount -uzq $LOCALMOUNTPATH >> /dev/null
mkdir -p $LOCALMOUNTPATH 2>&1 >/dev/null
echo $PWD | grep -q "^$" || PWDOPT="-o password_stdin"
#    DEVICE=$(ssh -q -o "RequestTTY force" $USR@$MSK "sudo prlctl exec $CT df -P" | tr '\r' '\n' | egrep "/$" | awk '{print $1}' | tr -d '\r' | tr -d '\n') >> /dev/null
#    VZPOINT=$(ssh -q -o "RequestTTY force" $USR@$MSK "df -P" | tr '\r' '\n' | grep "$DEVICE" | awk '{print $6}' | tr -d '\r' | tr -d '\n') >> /dev/null
echo $USR | grep -q root || SFTP_PATH=$(sshpass -p "$PWD" ssh -q -p ${PRT} -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o "RequestTTY force" $USR@$SRV "sudo grep sftp /etc/ssh/sshd_config" | awk '{print $3}' | tr -d '\r' | tr -d '\n')
echo $USR | grep -q root || SUDO_PATH=$(sshpass -p "$PWD" ssh -q -p ${PRT} -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o "RequestTTY force" $USR@$SRV "which sudo" | tr -d '\r' | tr -d '\n')
mkdir -p $LOCALMOUNTPATH 2>&1 >/dev/null
echo $USR | grep -q root || sshfs -p $PRT ${PWDOPT} -o sftp_server="${SUDO_PATH} ${SFTP_PATH}" -o allow_other,UserKnownHostsFile=/dev/null,StrictHostKeyChecking=no $USR@$SRV:/ $LOCALMOUNTPATH <<< "$PWD" 2>&1 >/dev/null
echo $USR | grep -q root && sshfs -p $PRT ${PWDOPT} -o allow_other,UserKnownHostsFile=/dev/null,StrictHostKeyChecking=no $USR@$SRV:/ $LOCALMOUNTPATH <<< "$PWD" 2>&1 >/dev/null
}

EXTERNAL_TERMINAL() {
[ "$USR" == "root" ] && sshpass -p "$PWD" ssh -q $VERBOSE -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o "RequestTTY force" -p $PRT $USR@$SRV  | tee -a $CLD_LOG
[ "$USR" == "root" ] || sshpass -p "$PWD" ssh -q $VERBOSE -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o "RequestTTY force" -p $PRT $USR@$SRV "sudo -i" | tee -a $CLD_LOG
}

[ "$TIMEOUT" ] || export TIMEOUT=300
EXTERNAL_DEPLOY() {
[ "$USR" == "root" ] && timeout ${TIMEOUT} sshpass -p "$PWD" ssh $1 -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o "RequestTTY force" -p $PRT $USR@$SRV "bash -s" 2>&1
[ "$USR" == "root" ] || timeout ${TIMEOUT} sshpass -p "$PWD" ssh $1 -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o "RequestTTY force" -p $PRT $USR@$SRV "sudo bash -s" 2>&1
}

[ "$TIMEOUT_NOTTY" ] || export TIMEOUT_NOTTY=300
EXTERNAL_DEPLOY_NOTTY() {
[ "$USR" == "root" ] && timeout ${TIMEOUT_NOTTY} sshpass -p "$PWD" ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p $PRT $USR@$SRV "bash -s" 2>&1
[ "$USR" == "root" ] || timeout ${TIMEOUT_NOTTY} sshpass -p "$PWD" ssh -q -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -p $PRT $USR@$SRV "sudo bash -s" 2>&1
}

EXTERNAL_UMOUNT() {
LOCALMOUNTPATH=`echo "/home/$SUDO_USER/mnt/$VM"` >> /dev/null ; fusermount -uzq $LOCALMOUNTPATH >> /dev/null ; rmdir $LOCALMOUNTPATH
}

CLOUDS_USER_ALLOWED() {
for OPTS in ${@:1}
do
echo $OPTS | grep -q  '^\--groups=' && CLD_GROUPS="$(echo $OPTS | cut -d '=' -f 2 | tr '\n' ',' | sed 's#,#$,#g' | tr ',' '\n')"
done
for GROUP in $(grep -v "^$\|^#" /var/cld/access/users/${SUDO_USER}/groups | grep "${CLD_GROUPS}")
do
cut -d _ -f -4 /var/cld/access/groups/${GROUP}/clouds | grep -vh "^$\|^#" 2>/dev/null
done
[ "$CLD_GROUPS" ] || cut -d _ -f -4 /var/cld/access/users/${SUDO_USER}/clouds | grep -vh "^$\|^#" 2>/dev/null
}

CHECK_DNS()
{
grep "$1" -qR --color=always /var/cld/modules/dns/data/*/`TZ=Europe/Moscow date +%F`/ \
&& echo "###############################################" \
&& echo "Info by matching first argument with DNS lists:" | grep --color=always "DNS" \
&& grep "$1" -R --color=always /var/cld/modules/dns/data/*/`TZ=Europe/Moscow date +%F`/ \
&& echo "###############################################" && echo
}

cldtailcut()
{
cat << CLDTAILCUT
${LINE:0:200}
${LINE:200:400}
${LINE:400:600}
CLDTAILCUT
}

cldtailfull()
{
cat << CLDTAILCUT
${LINE}
CLDTAILCUT
}

cldtaillogic()
{
[ ${#LINE} -gt 200 ] && cldtailcut || cldtailfull
}

cldtaillbegin()
{
[[ "${LINE}" =~ .*\>.*#BEGIN_DEPLOY ]] && BEGIN_DEPLOY=1 && cldtailfull
}

cldtail()
{
BEGIN_DEPLOY=$1
while IFS='' read -e LINE
do
[ "$BEGIN_DEPLOY" == "1" ] &>/dev/null && cldtailfull || cldtaillbegin
done
}

cldtail_old()
{
iln=0
while IFS='' read -e LINE
do
[ "$iln" -gt "$1" ] &>/dev/null && cldtaillogic || let iln++
done
}

echoexit1()
{
echo "${@:1}"
exit 1
}

INSTANCE_GROUP_FUNCS()
{
[ "$GROUP" ] || export GROUP=$(grep -l $VM /var/cld/access/groups/*/clouds | cut -d '/' -f 6 | tail -1)
if [ "$GROUP" = "" ] ; then echo "choosen CLOUD have incorrect GROUP" ; exit 1 ; fi
if grep -qs "1" /var/cld/access/groups/${GROUP}/funcs
then
source <(for GROUPFUNC in funcvars functerm funcmount funcumount funcdeploy funcdeploynotty
    do
      echo "${GROUP}_${GROUPFUNC}(){"
      cat /var/cld/access/groups/${GROUP}/${GROUPFUNC}
      echo '}'
    done)
  CLD_VARS=${GROUP}_funcvars
  CLD_MOUNT=${GROUP}_funcmount
  CLD_TERMINAL=${GROUP}_functerm
  CLD_UMOUNT=${GROUP}_funcumount
  CLD_DEPLOY=${GROUP}_funcdeploy
  CLD_DEPLOY_NOTTY=${GROUP}_funcdeploynotty
else
  CLD_VARS=EXTERNAL_VARS
  CLD_MOUNT=EXTERNAL_MOUNT
  CLD_TERMINAL=EXTERNAL_TERMINAL
  CLD_UMOUNT=EXTERNAL_UMOUNT
  CLD_DEPLOY=EXTERNAL_DEPLOY
  CLD_DEPLOY_NOTTY=EXTERNAL_DEPLOY_NOTTY
fi
}

CUSTOM_FUNCS_ACTIVATE(){
source  <(for GROUPFUNC in funcvars functerm funcmount funcumount 
    do
      echo "${GROUP}_${GROUPFUNC}(){"
      cat /var/cld/access/groups/${GROUP}/${GROUPFUNC}
      echo '}'
    done)
  alias EXTERNAL_VARS=${GROUP}_funcvars
  alias EXTERNAL_MOUNT=${GROUP}_funcmount
  alias EXTERNAL_TERMINAL=${GROUP}_functerm
  alias EXTERNAL_UMOUNT=${GROUP}_funcumount
  echo CUSTOM_FUNCS_ACTIVATE
}